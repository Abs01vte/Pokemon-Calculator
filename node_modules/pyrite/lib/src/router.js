"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const m = require("mithril");
class Router {
    build(configRoutes, currentRoutes = [], routes = {}) {
        configRoutes.forEach((route) => {
            const nextRoutes = currentRoutes.slice();
            nextRoutes.push(route);
            let allPaths = nextRoutes.map((element) => element.path);
            const path = allPaths.join("").split("//").join("/");
            routes[path] = this.createRoute(nextRoutes);
            if (route.routes)
                this.build(route.routes, nextRoutes, routes);
        });
        return routes;
    }
    addKeys(lastRoute, args) {
        lastRoute.props = lastRoute.props || {};
        const argsKeys = Object.keys(args);
        if (lastRoute.props && argsKeys.length) {
            lastRoute.props.key = argsKeys.map((key) => args[key]).join("/");
        }
    }
    createRoute(nextRoutes) {
        const otherRoutes = nextRoutes.slice();
        const lastRoute = otherRoutes.pop();
        const route = {
            onmatch: this.onmatch.bind(this, lastRoute),
            render: this.render.bind(this, otherRoutes, lastRoute)
        };
        return route;
    }
    onmatch(lastRoute, args, newPath) {
        this.addKeys(lastRoute, args);
        if (lastRoute.abstract && lastRoute.default) {
            m.route.set(newPath + lastRoute.default);
        }
        return lastRoute.component;
    }
    render(otherRoutes, lastRoute) {
        const render = otherRoutes.reduce((prev, next) => {
            return m(next.component, next.props, prev);
        }, m(lastRoute.component, lastRoute.props));
        return render;
    }
}
exports.Router = Router;
exports.router = new Router();
//# sourceMappingURL=router.js.map